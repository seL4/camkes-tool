/*
 * Copyright 2014, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 */

/*# Macros for use inside the templates. #*/

/*- macro marshal(buffer, param, size, pointer=False) -*/
    /*? buffer ?*/ = camkes_marshal(/*? buffer ?*/,
    /*- if not pointer -*/
        &
    /*- endif -*/
    /*? param ?*/, /*? size ?*/);
/*- endmacro -*/

/*- macro unmarshal(buffer, param, size, pointer=False) -*/
    /*? buffer ?*/ = camkes_unmarshal(/*? buffer ?*/,
    /*- if not pointer -*/
        &
    /*- endif -*/
    /*? param ?*/, /*? size ?*/);
/*- endmacro -*/

/*- macro marshal_string(buffer, param, pointer=False) -*/
    /*? buffer ?*/ = camkes_marshal_string(/*? buffer ?*/, /*- if pointer -*/ * /*- endif -*//*? param ?*/);
/*- endmacro -*/

/*- macro unmarshal_string(buffer, param, malloc=False, pointer=False) -*/
    /*- if not malloc and pointer -*/
        if (strlen((char*)*/*? param ?*/) < strlen(/*? buffer ?*/)) {
            */*? param ?*/ = realloc(*/*? param ?*/, sizeof(char) * (strlen(/*? buffer ?*/) + 1));
            assert(*/*? param ?*/ != NULL);
	}
    /*- else -*/
        /*- if malloc -*/
            /*- if pointer -*/ * /*- endif -*//*? param ?*/ = 
                malloc(sizeof(char) * (strlen(/*? buffer ?*/) + 1));
            assert(/*- if pointer -*/ * /*- endif -*//*? param ?*/ != NULL);
        /*- endif -*/
    /*- endif -*/
    /*? buffer ?*/ = camkes_unmarshal_string(/*? buffer ?*/, /*- if pointer -*/ * /*- endif -*//*? param ?*/);
/*- endmacro -*/

/*- macro marshal_array(buffer, param, size, pointer=False) -*/
    /*? marshal(buffer, '%s_sz' % param, 'sizeof(size_t)', pointer) ?*/
    for (int i = 0; i < /*- if pointer -*/ * /*- endif -*/ /*? param ?*/_sz; i++) {
        /*? marshal(buffer, '(%s%s)[i]' % ('*' if pointer else '', param), size) ?*/
    }
/*- endmacro -*/

/*- macro unmarshal_array(buffer, param, size, pointer=False, malloc_cast='') -*/
    size_t /*? '%s_sz_ret' % param ?*/;
    /*? unmarshal(buffer, '%s_sz_ret' % param, 'sizeof(size_t)') ?*/
    if (/*- if pointer -*/ * /*- endif -*//*? '%s_sz' % param ?*/ < /*? '%s_sz_ret' % param ?*/) {
	/*- if pointer -*/ * /*- endif -*//*? '%s_sz' % param ?*/ = /*? '%s_sz_ret' % param ?*/;
        /*- if malloc_cast -*/
            /*- if pointer -*/ * /*- endif -*/ /*? param ?*/ = (/*? malloc_cast ?*/ *)realloc(/*- if pointer -*/ * /*- endif -*//*? param ?*/, /*- if pointer -*/ * /*- endif -*/ /*? param ?*/_sz * sizeof(/*? malloc_cast ?*/));
            assert(/*? param ?*/ != NULL);
        /*- endif -*/
    }

    for (int i = 0; i < /*- if pointer -*/ * /*- endif -*/ /*? param ?*/_sz; i++) {
        /*? unmarshal(buffer, '(%s%s)[i]' % ('*' if pointer else '', param), size) ?*/
    }
/*- endmacro -*/

/*- macro header_guard(filename) -*/
    /*- set guard_def = '_CAMKES_' + filename.upper() + '_' -*/
    #ifndef /*? guard_def ?*/
    #define /*? guard_def ?*/
/*- endmacro -*/

/*- macro header_file(filename) -*//*? '.'.join(filename.split('.')[:-1]) + '.h' ?*//*- endmacro -*/

/*- macro thread_stack(sym) -*/
    char /*? sym ?*/[ROUND_UP_UNSAFE(CONFIG_CAMKES_DEFAULT_STACK_SIZE, PAGE_SIZE_4K) + PAGE_SIZE_4K * 2]
        __attribute__((externally_visible))
        __attribute__((aligned(PAGE_SIZE_4K)));
/*- endmacro -*/

/*- macro ipc_buffer(sym) -*/
    char /*? sym ?*/[PAGE_SIZE_4K * 3]
        __attribute__((externally_visible))
        __attribute__((aligned(PAGE_SIZE_4K)));
/*- endmacro -*/

/*- macro save_ipc_buffer_address(sym) -*/
    #ifdef ARCH_IA32
        /* We need to save the address of the IPC buffer (for
         * marshalling/unmarshalling) per-thread. Essentially what we're after
         * is TLS. Use the IPC buffer's user data word for that. Note that we
         * add a page to skip over the guard page in front of the IPC buffer.
         */
         seL4_SetUserData((seL4_Word)/*? sym ?*/ + 2 * PAGE_SIZE_4K - sizeof(seL4_IPCBuffer));
     #endif
/*- endmacro -*/

/*- macro show_includes(xs, prefix='') -*/
    /*- for header in xs -*/
        /*- if header.relative -*/
            #include "/*? prefix ?*//*? header.source ?*/"
        /*- else -*/
            #include </*? header.source ?*/>
        /*- endif -*/
    /*- endfor -*/
/*- endmacro -*/
